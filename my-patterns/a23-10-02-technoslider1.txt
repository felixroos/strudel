let fadeGain = (p,b) => p<.5?1:1-(p-.5)/.5

let xfade = (a, pos, b) => {
  pos = reify(pos);
  a = reify(a)
  b = reify(b)
  let gaina = pos.fmap(v=>fadeGain(v)).gain();
  let gainb = pos.fmap(v=>fadeGain(1-v)).gain();
  return stack(
    a.mul(gaina),
    b.mul(gainb))
}
  

// the prototype version is actually flipped so left/right makes sense
Pattern.prototype.xfade = function(pos,b) {
  return xfade(this,pos,b)
}

// 

stack(
  
  xfade(
    // BASS
    s("sawtooth(3,8,<0@3 1>):0:.5").note(30)
    .juxBy(slider(0.193),rev)
    .lpenv(slider(0).range(-4,4))
    .lpa(slider(0.583).range(.05,.1))
    .lpf(slider(200,200,2000))
    .sometimesBy(
      slider(0.152),
      add(note("<12 7>/2"))
    ), 
  slider(0.553), // fade BASS <-> FX turn me left!
    // FX
    s("<crow space:<1 0>:.1>(3,8,1)").delay(.25).room(1.5)
    .speed(slider(0.625)).cut(1).ds(".1:0")
    .mul(speed(perlin.range(slider(0.6855,.5,1),1)))
    .lpf(slider(1471.4,200,8000))
    .mul(gain(slider(0.511)))
  ).early(.001)
  ,
  // DRUMS
  xfade(
    stack(
      // KICK
      s("bd*2")
      .mul(gain(slider(1)))
      ,
      // SNARE
      s(" ~ sd:1:.5*<1!7 [2 4]>").cut(2)
      .mul(gain(slider(0))) // snare gain
    )
    .hpf(slider(0,0,300)) // hpf: turn me left!
    ,
  slider(0.314), // fade kick/snare <-> hihat
    // HIHAT
    
    s("hh*8") //              v hihat gain consistency
    .gain(rand.range(slider(0.367),1))
    .mul(gain(slider(0.42))) 
    .speed(slider(1))
    .end(slider(0.106))
    .release(.05).late(.001) //   v hihat pitch stability
    .mul(speed(rand.range(slider(0.636),1)))
    
  )
  .bank('RolandTR808')
  .note(36)        //           v move right !
)
  // GLOBAL
  .reset("x".fast("2".pow(slider(0,0,3).round())))
  .degradeBy(slider(0))
  .mul(gain(slider(1)))



// another idea: instead of 2 inputs there could be a select function that
// takes an array of patterns and an index or maybe just 0-1?