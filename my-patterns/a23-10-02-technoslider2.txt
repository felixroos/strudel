let fadeGain = (p,b) => p<.5?1:1-(p-.5)/.5

let xfade = (a, pos, b) => {
  pos = reify(pos);
  a = reify(a)
  b = reify(b)
  let gaina = pos.fmap(v=>fadeGain(v)).gain();
  let gainb = pos.fmap(v=>fadeGain(1-v)).gain();
  return stack(
    a.mul(gaina),
    b.mul(gainb))
}
  

// the prototype version is actually flipped so left/right makes sense
Pattern.prototype.xfade = function(pos,b) {
  return xfade(this,pos,b)
}

// 

stack(
  
  xfade(
    chord("<Am Dm>/16")
    .layer(
      // BASS
      x=>x.set.out(n("-8(3,8,<0@3 1>)")).voicing()
      .s("sawtooth:0:.5")
    .juxBy(slider(0.193),rev)
    .lpenv(slider(0).range(-4,4))
    .lpa(slider(0.583).range(.05,.1))
    .lpf(slider(200,200,2000))
    .sometimesBy(
      slider(0.318),
      add(note("<12 7>/2"))
    ),
      x=>x
        .delay(".25:.125:.9")
        .struct("~ x*<1!3 2>")
        .set.mix(offset("<0!3 2>"))
        .voicing()
        .s("sawtooth:0:.125")
        .room(.5)
        .lpenv(slider(0.443).range(-8,1))
        .lpa(slider(0.549).range(.05,.1))
        .lpf(slider(718.4,200,2000))
    ), 
  slider(0.314), // fade BASS <-> FX turn me left!
    // FX
    s("<crow space:<1 0>:.1>(3,8,1)").delay(.25).room(1.5)
    .speed(slider(0.625)).cut(1).ds(".1:0")
    .mul(speed(perlin.range(slider(0.6855,.5,1),1)))
    .lpf(slider(2150,200,8000))
    .mul(gain(slider(0.417)))
  ).early(.001)
  ,
  // DRUMS
  xfade(
    stack(
      // KICK
      s("bd*<2!7 [2 8]>").cut(8)
      .mul(gain(slider(1)))
      ,
      // SNARE
      s(" ~ sd:0:.5*<1!7 [2 4]>").cut(2)
      .mul(gain(slider(1))) // snare gain
    )
    .hpf(slider(0,0,300)) // hpf: turn me left!
    ,
  slider(0.496), // fade kick/snare <-> hihat
    // HIHAT
    
    s("hh*8") //              v hihat gain consistency
    .gain(rand.range(slider(0.625),1))
    .mul(gain(slider(0.133))) 
    .speed(slider(0.508))
    .end(slider(0.023))
    .release(.05).late(.001) //   v hihat pitch stability
    .mul(speed(rand.range(slider(0.917),1)))
    .lpf(slider(4101,1000,8000))
    
  )
  .bank('RolandTR808')
  .note(36)        //           v move right !
)
  // GLOBAL
  .reset("x".fast("2".pow(slider(0,0,3).round())))
  .degradeBy(slider(0))



// another idea: instead of 2 inputs there could be a select function that
// takes an array of patterns and an index or maybe just 0-1?